---
title: Error Handling
description: Patterns for handling network errors, API failures, and retry strategies in AI agent interfaces.
---

# Error Handling

Robust error handling is essential for AI applications. Users must always understand what went wrong and what they can do next. This guide covers common error scenarios and recovery patterns.

## Error categories

| Category | Examples | User impact |
| --- | --- | --- |
| Network | Timeout, disconnection, DNS failure | Cannot send or receive messages |
| Server | 500 errors, rate limits (429) | Agent cannot respond |
| Agent | Low confidence, no answer, hallucination guard | Response may be unhelpful |
| Validation | Empty message, too long, blocked content | Message not sent |

## Network errors

### Connection lost

```tsx
import { Alert } from '@surf-kit/core';

function ConnectionStatus({ isOnline }) {
  if (isOnline) return null;

  return (
    <Alert intent="warning" title="You are offline">
      Your internet connection has been lost. Messages will be sent when
      you reconnect.
    </Alert>
  );
}
```

### Timeout handling

```tsx
async function sendWithTimeout(message: string, timeoutMs = 30000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

  try {
    const response = await fetch('/api/agent', {
      method: 'POST',
      body: JSON.stringify({ message }),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      throw new ServerError(response.status, await response.text());
    }

    return response;
  } catch (error) {
    clearTimeout(timeoutId);

    if (error instanceof DOMException && error.name === 'AbortError') {
      throw new TimeoutError('The request took too long. Please try again.');
    }

    throw error;
  }
}
```

## Retry patterns

### Exponential backoff

```tsx
interface RetryConfig {
  maxRetries: number;
  baseDelay: number;
  maxDelay: number;
}

async function withRetry<T>(
  fn: () => Promise<T>,
  config: RetryConfig = { maxRetries: 3, baseDelay: 1000, maxDelay: 10000 }
): Promise<T> {
  let lastError: Error;

  for (let attempt = 0; attempt <= config.maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;

      if (attempt === config.maxRetries) break;

      // Do not retry client errors (4xx except 429)
      if (error instanceof ServerError && error.status >= 400 && error.status < 500 && error.status !== 429) {
        break;
      }

      const delay = Math.min(
        config.baseDelay * 2 ** attempt + Math.random() * 1000,
        config.maxDelay
      );

      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }

  throw lastError!;
}
```

### Retry UI

```tsx
function RetryableMessage({ error, onRetry, retryCount }) {
  return (
    <div className="rounded-lg border border-destructive/50 p-4">
      <Alert intent="error" title="Something went wrong">
        {error.message}
      </Alert>
      <div className="mt-3 flex items-center gap-3">
        <Button intent="secondary" onPress={onRetry}>
          Try again
        </Button>
        {retryCount > 0 && (
          <span className="text-sm text-muted-foreground">
            Attempt {retryCount} of 3
          </span>
        )}
      </div>
    </div>
  );
}
```

## Rate limiting

### Handling 429 responses

```tsx
async function handleRateLimit(response: Response) {
  if (response.status === 429) {
    const retryAfter = response.headers.get('Retry-After');
    const waitSeconds = retryAfter ? parseInt(retryAfter) : 60;

    return {
      type: 'rate-limited',
      message: `Too many requests. Please wait ${waitSeconds} seconds.`,
      retryAfter: waitSeconds,
    };
  }

  return null;
}
```

### Rate limit UI

```tsx
function RateLimitBanner({ retryAfter }) {
  const [secondsLeft, setSecondsLeft] = React.useState(retryAfter);

  React.useEffect(() => {
    const interval = setInterval(() => {
      setSecondsLeft((s) => {
        if (s <= 1) {
          clearInterval(interval);
          return 0;
        }
        return s - 1;
      });
    }, 1000);
    return () => clearInterval(interval);
  }, [retryAfter]);

  if (secondsLeft === 0) return null;

  return (
    <Alert intent="warning">
      You are sending messages too quickly. Please wait {secondsLeft} seconds.
    </Alert>
  );
}
```

## Agent-level errors

### Low confidence fallback

```tsx
function ConfidenceFallback({ message, confidence }) {
  if (confidence < 0.3) {
    return (
      <div>
        <Alert intent="warning" title="I'm not sure about this">
          I could not find a confident answer to your question. Here is what I
          found, but I recommend contacting the service directly for
          confirmation.
        </Alert>
        <div className="mt-3 prose">{message.content}</div>
      </div>
    );
  }

  return <div className="prose">{message.content}</div>;
}
```

### Content filter

```tsx
function ContentFilterAlert() {
  return (
    <Alert intent="info" title="I cannot help with that">
      I am designed to help with digital services. I am not able to assist with
      this particular request. Please try rephrasing your question or contact
      the service directly.
    </Alert>
  );
}
```

## Error boundary

Wrap the chat interface in a React error boundary to catch unexpected failures:

```tsx
import { Alert, Button } from '@surf-kit/core';

class ChatErrorBoundary extends React.Component {
  state = { hasError: false, error: null };

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="flex flex-col items-center justify-center p-8 gap-4">
          <Alert intent="error" title="Something went wrong">
            The chat interface encountered an unexpected error. Please refresh
            the page to try again.
          </Alert>
          <Button onPress={() => window.location.reload()}>
            Refresh page
          </Button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

## Accessibility

- Error messages must use appropriate ARIA roles (`role="alert"` for errors, `role="status"` for warnings).
- Retry buttons must be keyboard accessible and clearly labelled.
- Countdown timers (e.g., rate limiting) should be announced to screen readers.
- Never show raw error codes or stack traces to users.
- Always provide a clear next action (retry, wait, contact support).
